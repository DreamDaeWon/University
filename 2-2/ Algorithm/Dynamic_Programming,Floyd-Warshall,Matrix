==Dynamic Programming==

다이나믹 프로그래밍은 문제 종류가 많고, 
컴퓨터적인 사고를 물어보기에는 적합하다는 점에서 자주 출제 대회에서 많이 쓰인다.

다이나믹 프로그래밍은 하나의 문제를 단 한 번만 풀도록 하는 알고리즘이다.
한 번 푼 것을 여러 번 다시 푸는 것은 비효율적이기 때문에
한 번 풀고나서 그 값을 저장해서 다시 그 문제를 요구할 때는 이미 구한 값을 제시해주는 방식으로 한다.

일반적으로 상당수의 분할정복 기법은 동일한 문제를 다시 푼다는 단점이 있다.

(그러나 퀵 정렬이나 병합정렬 같이 정렬과같은 몇몇 요소인 경우에는 동일한 문제를 다시 푸는 경우가 없다.)

대표적인 분할정복 중에서 피보나치 수열이 그 예이다.

피보나치 수열은 예를 들어 피보나치 수열에서 15번째 값을 구하고 싶을 때 14번째 값과 13번째 값을 구해서 합쳐서 구한다.


퀵 정렬같은 경우에는 1~7의 값을 1~3과 1~4로 나누어 정렬을 수행한 뒤에 
합치기 때문에 다시 똑같은 문제를 풀지 않는다.

그러나 피보나치 수열같은 경우에는 15번째 값을 구하고 싶을 때
14번째 값과 13번째 값을 알아와서 합쳐야 한다.
여기에서 14번째 값을 구하기 위해서는 13번째 값과 12번째 값이 필요하고,
13번째 값을 구하기 위해서는 12번째 값과 1번째 값을 구해야 한다.

이런식으로 하나를 구하기 위해서 문제가 계속해서 늘어가게 된다.
이 때 n번째 값을 구하기 위해서는 O(2^n)만큼의 계산과정을 거쳐야 한다.

하지만 하나하나 구할 때마다 해당 결과를 저장해두면 다음번에 
그 값을 사용해야 할 때 새로운 계산이 아닌 해당 결과의 값을
가져오면 되기 때문에 문제의 과정을 줄일 수 있다.

그래서 피보나치 수열을 다이나믹 프로그래밍 방식으로 구현할 때
피보나치 수열을 계산하는 함수와 그 값을 저장하는 배열로 구현한다.
배열의 해당 위치에 값이 있으면 그 값을 쓰고 없다면 해당 값을 구하기 위한
루프를 돌게된다.

이렇게 된다면 시간복잡도가 O(n)으로 줄어들게 된다.

이렇게 구현하는 방식이 다이나믹 프로그래밍이다.

이런식으로 다이나믹 프로그래밍을 하기 위해서는 2가지 조건이 필요하다.

1. 큰 문제를 작은 문제로 나눌 수 있는경우 (작은 문제의 구조가 큰 문제의 구조와 같은 경우)
2. 작은 문제에서 구한 정답이 그것을 포함하는 큰 문제에서 사용되는 경우

이렇게 2 가지 조건을 만족해야 한다. 

작은 문제와 큰 문제를 구하는 과정에서 예외 과정을 처리해주어야 하는데 이러한 예외가
적어야 다이나믹 프로그래밍을 하기 좋다.


==Floyd-Warshall==

하나의 정점에서 출발했을 때 다른 모든 정점으로의 최단 경로를 구하는 알고리즘인
다익스트라 알고리즘과 다르게

플로이드 와샬 알고리즘은 모든 정점에서 모든 정점으로의 최단 경로를 구하는 알고리즘이다.

쉽게말해 다익스트라는 출발점에서 다른 모든 정점,
플로이드 와샬은 모든 정점에서 모든 정점으로 까지의 최단거리를 구하는 것이다.

다익스트라 알고리즘은 가장 적은 비용을 하나씩 선택하는 그리디 알고리즘 형태였다.

플로이드 와샬은 기본적으로 거쳐가는 정점을 기준으로 수행한다는 특징이 있다.

다익스트라 알고리즘은 매번 가장 적은 비용을 가지는 노드를 하나씩 꺼내서
그 노드를 거쳐가는 비용을 계산했다면

플로이드 워샬 같은 경우에는 반복문의 중심에 거쳐가는 정점을 두어서
정점을 정하고 해당 정점을 거쳐가는 비용을 계산해서 최소값을 구하는 방식이다.

다익스트라 알고리즘과 마찬가지로 단계별로 거쳐가는 노드를 기준으로 알고리즘을 수행하지만,
매 단계마다 방문하지 않은 노드 중에 최단 거리를 갖는 노드를 찾는 과정이 필요하지 않다.
2차원 배열로 최단거리를 저장하면서 구현하기 때문이다. (다이나믹 프로그래밍)


플로이드 워샬 같은 경우에는 2차원 배열로 데이터를 저장한다.

큰 문제를 작은 문제로 나눌 수 있고 작은 문제의 값이 큰 문제를 해결하는데 쓰이기 때문에
2차원 배열로 저장한다. 즉 플로이드 워셜 알고리즘은 다익스트라 알고리즘이다.

정점이 4개라면

노드번호		1			2			3			4


1			1->1비용		1->2비용		1->3비용		1->4비용

2			2->1비용		2->2비용		2->3비용		2->4비용

3			3->1비용		3->2비용		3->3비용		3->4비용

4			4->1비용		4->2비용		4->3비용		4->4비용


이런식으로 표가 구성된다.

이 때 갈 수 있는 길이 없으면 무한이 된다.

	1 --(5)--> 2
	|
	|
	(3)
	|
	|
	v
	4 ---(2)--> 3

이런식으로 노드가 그래프가 그려져 있다면


노드번호		1			2			3			4


1			0			5			무한			3

2			무한			0			무한			무한

3			무한			무한			0			무한

4			무한			무한			2			0

이런식으로 표가 구성이 된다.


이제 이 다음부터는 노드 1을 거쳐서 가는 경우를 계산한다.

노드 2 3 4 입장에서 노드 1을 거쳐서 다른 노드로 가는 경우는 존재하지 않기 때문에 똑같이 모두 무한이 된다.
노드 1은 본인을 거쳐가는 것이기 때문에 변화가 없다.

노드번호		1			2			3			4


1			0			5			무한			3

2			무한			0			무한			무한

3			무한			무한			0			무한

4			무한			무한			2			0


그럼 여기서 만약 4를 거쳐서 가는 경우에는?


노드번호		1			2			3			4


1			0			5			무한->5		3

2			무한			0			무한			무한

3			무한			무한			0			무한

4			무한			무한			2			0



이런식으로 1번 노드가 4를 거쳐서 3번노드로 가는 길이 있고 해당 비용은 5이다.

이 때 무한>5 이므로 4번노드를 거쳐서 3번노드로 가는 비용이 5로 기존에 무한이었던 값보다 작기 때문에
2차원배열을 업데이트 해준다.


이런 방식으로 1번노드를 거치는 경우~4번노드를 거치는 경우를 모두 보면서 표를 갱신하면
모든 정점에서 모든 정점으로 가는 최소거리를 계산할 수 있다.


점화식을 이용하여 3중포문을 돈다.

Dab = min(Dab, Dak + Dkb) 이다.

Dab는 A->B로 가는 최단거리를 말한다.

코드로 구현할 때는 a,b,k를 계속 바꿔주면서 삼중포문을 돌기 때문에
시간복잡도는 O(n^3)이 된다.

보통 플로이드 워셜 알고리즘을 사용하는 문제는 노드의 개수가 500개 이하로 나오는 경우가 많다.

문제마다 다익스트라 플로이드 워셜 중에서 어떠한 알고리즘을 수행해야하는 지 고민해볼 필요가 있다.



==행렬 기본(덧셈, 뺄셈, 곱셈)==

행렬은 영어로 Matrix이다.

컴퓨터는 거의 모든 연산 자체를 행렬로 계산한다.

행렬은 행과 열로 이루어진 박스이다.

행은 가로 열은 3열이다.

만약

1	2	3
1	2	3

이렇게 행렬이 있으면 행이 2 열이 3이다
즉 2행3열 행렬이므로 2x3으로 표현한다.

위 행렬의 이름이 a면

a23은 a의 2행 3열 원소를 뜻한다. 위 행렬에서는 3이다.

행렬의 덧셈은 간편하다.


2	4				3	5
5	6		+ 		4	7

이런식으로 있으면 같은 행과 같은 열을 더해주면 된다.

위 식에서는 답이

5	9
9	13 이 된다.

뺄셈도 동일하다.

같은 행과 열에 위치한 원소를 빼주면 된다.

2	4				3	5
5	6		- 		4	7

이런 식이면

정답은

-1	-1
1	-1 이 된다.



행렬의 곱셈

행렬의 곱셈은 순서가 중요하다.

앞쪽 행렬의 행과 뒤쪽행렬의 열을 내적하면 된다.

즉 내적의 연속이다.

1	2	3				2	5	9
1	2	3 		x		4	6	8

 이런식으로 되어있다면?

연산못한다. 왜냐면

2x3 과 2x3 이기 때문에 앞의 행렬의 행과 뒤의 행렬의 열의 값이 같지 않아서

연산이 불가능하다.

1	2	3				4	5	8
1	2	3		x		9	6	8
						7	8	6

이런경우에는? 가능하다.

그 이유는? 앞의 행렬 2x3 곱하기 뒤의 행렬 3x3 이기 때문에

행과 열의 개수가 일치해서 가능하다.

즉 행렬의 조건은

nxk	x	kxm		이런식으로 이루어져야 하고

이 때 결과는 nxm 모양의 행렬이 된다.

4	5				5	9	8
7	8		x		4	8	7

이런 행렬이 있을 때


결과는

4	5	?1	?2	?3
7	8	?4	?5	?6
		
		5	9	8
		4	8	7
		

?1 = (4 * 5) + (5 * 4) = 40

?2 = (4 * 9) + (5 * 8) = 76

?3 = (4 * 8) + (5 * 7) = 77

?4 = (7 * 5) + (8 * 4) = 67

?5 = (7 * 9) + (8 * 8) = 127

?6 = (7 * 8) + (8 * 7) = 112

이런식으로 되어서 최종적으로는 



4	5	40	76	77
7	8	67	127	112
		
		5	9	8
		4	8	7


4	5				5	9	8				40	76	77
7	8		x		4	8	7		=		67	127	112


이렇게 된다.

이런식으로 행렬의 곱을 하면 된다.


행렬의 연산에는 나눗셈이 없다.

나눗셈은 역행렬이라는 것을 곱해서 만들어지는 것이다.



== 행렬 곱셈 알고리즘 ==

위에 행렬의 곱에 대해서 알아보았다.

위의 행렬의 곱셈을 어떤 식으로 나타내 보면

pxq qxr 행렬의 곱을 하면

pxr 행렬이 만들어지고

총 수행시간은 O(pqr)이다.

기본연산을 하게 된다.

만약 3개의 행렬을 하면?

만약 M1이 2x3행렬이고

만약 M2가 3x2행렬이고

만약 M3가 2x5행렬이라고 가정하면

M1 x M2 x M3

행렬은 괄호를 닫는 것 즉 결합법칙은 성립하기 때문에

(M1 x M2) x M3 = M1 x (M2 x M3)

이렇게 된다.

이렇게 되면 위에서 구한 수행시간에 따라서

O(pqr) 이기 때문에


1. (M1 x M2) x M3 <- 이런 순서로 계산한다고 가정한다면,

2x3 x 3x2 x 2x5 = 2x3x2 + 2x2x5 = 12 + 20 = 32

즉 약 32번 정도의 계산을 한다는 것이다.



2. M1 x (M2 x M3) <- 이런 순서로 계산한다고 가정한다면,

2x3 x (3x2 x 2x5) = (3x2x5) + (2x3x5) = 30 + 30 = 60

즉 약 60번 정도의 계산을 한다는 것이다.

???????? 띠용

분명히 행렬 곱셈의 값을 위와 아래 모두 같은 값이 나오지만

기본연산을 하는 횟수가 달라지기 때문에 위의 2가지 방법중에서는

1번 방법을 택해야 하는 것이다.


결국 입력이 주어졌을 때 어떤 순서에 따라서 해야 기본연산의 횟수가 최소가 될까?

괄호를 묶을 수 있는 모든 경우의 수를 찾아서 하나하나 해당 경우의 연산횟수를 정할 수도 있다.

하지만 그러기에는 나중에 곱하는 행렬의 개수가 많아지면 하나하나 다 연산횟수를 계산하면서
가장 적은 경우를 찾는 것은 힘들다.

추후에 이런 문제를 동적계획법으로 굉장히 빠르게 풀 수 있다고 한다.


== 최소 편집 알고리즘 ==

다이나믹 프로그래밍 문제 중 하나이다.

최소 편집 알고리즘은 단어가 2개가 주어지고

첫번째 단어를 두번째 단어로 바꾸기 위해서 몇 번의 동작을 해야하는 지
찾는 알고리즘 이다.


오퍼레이션의 종류는 3 가지가 있다.
1. 단어를 삽입
2. 단어를 삭제
3. 글자를 교체


horse를 ros로 바꾼다는 예를 보면


첫번째 글자인 h를 r로 바꾸고 -> rorse

여기에서 2번째 r을 재거한다 -> rose

마지막으로 맨 마지막 글자인e를 제거하면 -> ros

이렇게 3번의 과정을 거치면 ros로 바뀐다.

이런식으로 어떤 단어를 원하는 단어로 바꿀 때까지
걸리는 최소 과정을 확인하는 것이다.

2차원 배열로 확인한다.

결국에 대각선 위쪽
위쪽
왼쪽

이 3가지 중에서 제일 작은 것을 취해서 +1 해주면 된다.


==0-1 knapsack==

0-1 배낭문제는

분할을 할 수 없는 배낭문제이다.

이때 무엇을 분할 할 수 없냐면

배낭에 넣을 아이템을 분할할 수 없다.


배낭의 용량을 넘지 않으면서 가치가 최대가 되는 아이템 집합의 부분집합을 찾는 문제이다.

결국 최종 아이템의 무게는 배낭의 용량보다 작거나 같다.

만약 쪼갤 수 있다면 그냥 같겠지만 여기서는 쪼갤 수 없으므로 작거나 같을 수밖에 없다.


0-1 배낭문제를 동적 계획법으로 풀면

p[i][w] : 총 무게가 w를 초과할 수 없다는 제약조건이 있기 때문에 처음 i개 아이템에서만
선택할 때 얻는 최적의 이익을 말한다.

p[n][w] : n 개의 아이템으로 얻을 수 있는 최대의 이익을 뜻한다.

















