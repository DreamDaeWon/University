그리디 알고리즘을 사용하는 경우는

나이트 투어같은 경우에 사용한다.

나이트 투어같은 경우에는 10년이 지나도 해결하지 못할 것이라고 생각하기 때문에 그리디 알고리즘으로 한다.


그리디 알고리즘은 지금 생각하는 답이 최고일 것이라고 믿고 다음으로 가는 것이다.

즉 정확히 정답은 아닐지라도 정답에 가까이 갔을 것이다. 라고 생각하는 것이다.

 


==집합 커버문제==

선택하는 집합의 수를 최소화 하는 문제

마을이 여러개 있고

어느 위치에 학교를 지어야 모든 마을이 학교로 15분 내로 등하교 할 수 있는지
구하는 경우에 사용된다.


어느 위치에 지으면 어느 마을이 커버되는 지에 대해 묶어놓은 집합 S

S들의 집합 F


모든 마을의 집합 U


위 상황에서 구하는 알고리즘의 시간복잡도는
O(2^n-1) 이다.

근데 2^n같은 경우에는  n 이 조금만 커져도 불가능하다.

그래서 해당 문제같은 경우에는 그리디 알고리즘을 사용할 수 있다.


1. 현재 상황에서 커버해야할 마을의 집합 U 의 원소를 가장많이 커버할 수 있는 S를 찾는다.

2. U = U-S

2-1 F = F - S (가장 많은 집합을 집합의 집합? 에서 제외시킨다.)

3. 위 과정을 반복하면서

while (U != 공집합)
{

}

이렇게 반복한다.

이렇게 되면

시간복잡도가 O(n^3)인 알고리즘이 된다.




==============================

u = 출발점

d = 도착점과 가중치의 딕셔너리


정점에서 정점을 커버하는 문제

정점에서 간선을 커버하는 문제 이렇게 2개로 나뉜다.

나뉘지만 데이터를 준비하는 과정만 달라지고

구현은 동일하게 된다.


==================================

크루스칼 알고리즘 O(mlogm)

프림 알고리즘(nlogn), O(n^2) 이지만 줄어들었다 이유도 알아야 함




배낭문제 같은 경우에는 0-1 같은 경우에는 그리디 알고리즘으로 풀 수 없다.

작업 스케쥴링이나 허프만 알고리즘 같은 경우에는 시간복잡도를 기억해 두는 것이 좋다.



== 동적 계획 알고리즘(DP) ==

1. 큰 문제를 작은 부분 문제로 나누고

2. 부분 문제의 해를 저장해둔다.(다음에 사용할 일이 있기 떄문)


분할정복은 DP와 달리 부분문제의 해를 중복 사용하지 않는다.



다익스트라는 점을 정해둔다.




모든 쌍 최단 경로는 점을 안정한다. (모든 점에 대하여 구하기 때문)

- 다익스트라 반복 O(n^2 logn)

- 플로이드 워샬O(n^3)


다익스트라 알고리즘이 더 빠른거 아니야??
아니다.

이유는 다익스트라가 어느정도까지는 더 느릴 것이다. 

즉, n이 상당수 숫자가 되기 전까지는 플로이드 워샬 알고리즘이 더 빠를것입니다.

왜냐? 코드가 단순하기 때문이다.

물론 n이 커지면 나중에는 다익스트라가 더 빠르게 역전이 되긴 한다.



기존에 알고있는 방법보다 더 빠른게 있으면 갱신

최종적으로 구하려는 것은 모든 점을 통해 갔을 때에 대한 값이다.


Dij^k = i->j 까지 k점을 포함하여 가는 거리

즉 k = 0 이면 i->j로 바로 가는 거리이다.


즉 최종적으로 Dij^k는


예를 들어 Dij^2가 있다면

					Dij^2
					/	\
				Di2^1		  D2j^1
			      /	     \		   /	   \
			Di1^0	    D1j^0	D21^0    D1j^0

이런식으로 계속 문제를 나누면서 간다. 
또한 하나를 구하려면 더 작은 부분문제의 답이 필요하다.
즉 다이나믹 프로그래밍이다.

이게 플로이드 워샬 알고리즘이다.

Dik^(k-1) + Dkj^(k-1)으로도 표현할 수 있다.

이거 구현할 때는

모든 점에서 직접가는 길을 쏵 구해둔다.


그리고 해당 문제들을 따라 올라가면서 한다.
down-up방식으로 한다.








