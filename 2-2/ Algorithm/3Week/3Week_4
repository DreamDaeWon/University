정렬 문제를 푸는 법을 2가지로 나타낼 수 있다.

비교정렬 (Comparison Sort)
비교정렬은 어느것이 더 큰 지 비교를 하면서 작은것은 왼쪽으로 큰것은 오른쪽으로 보내면서 하는 정렬방법들을 말한다.

대표적으로 버블, 선택, 삽입, 쉘, 힙, 합병, 퀵 등등이 있다.
비교가 숫자 대 숫자로 이루어진다.



기수정렬 (Radix Sort)
기수정렬은 비교정렬이 아니다
숫자들을 한 자리씩 부분적으로 비교한다.

하한 = 이것보다는 빠를 수 없다.


최댓값을 찾는 문제의 하한

어떤 방식으로 탐색하든지 적어도 (n-1)번의 비교가 필요하다. 
즉 최댓값을 찾아야 하는 경우에는 O(n-1)이 하한이다.



비교정렬의 하한

비교정렬의 하한은 O(nlogn) 이다.


계수정렬(Count Sort)
카운트 소트는 모든 원소에서 가장 큰 수와 가장 작은 수의 차이가 크지 않을 때 사용한다.

가장 작은수 부터 가장 큰 수까지의 배열을 만들고 배열을 쭉 순회하면서
배열의 인덱스와 같은 숫자의 자료가 있을 경우
해당 인덱스의 값을 1 올리는 방식이다.

그 후 0번째 인덱스에 값이 3
즉 배열에 0이 3개 있다면
다음 인덱스인 1의 값에 3을 더한다
이런식으로 모든 작은수~큰수 배열의 각각의 값을
앞 인덱스 + 본인 인덱스의 값 이렇게 바꿔준다.

위 작업을 해준 뒤

원래 배열을 순회하면서 작은수~큰수 배열의 인덱스와 같은 값을 찾으면
작은수~큰수배열[원래배열순회값] -= 1; 해주고

작은수~큰수 배열의 해당 인덱스의 값;
즉 
최종 정렬 배열 [작은수~큰수[원래배열순회값]];
이렇게 넣어준다.

이게 count sort이다.
굉장히 빠르다

진짜 빠르다

시간복잡도는 O(k(n + r))
r : 숫자의 종류
K : 자리수

근데 여기서? k r은 상수로 보고 지우면?

최종적으로 시간복잡도는 O(n)이다


기수정렬(Radix Sort)
기수정렬은 Count Sort같은 경우에는 0~1000이런식으로 범위가 커지면
메모리 낭비가 굉장히 심해질 수 있다.

그래서 그것을 나눠서 한다는 아이디어 이다.

뭘 어떻게 나눌꺼냐??

세자리 수면 백의 자리, 십의 자리, 일의 자리 이렇게 나누어서

먼저 일의자리 그 다음 십의자리 그 다음 백의자리
이렇게 자리 수를 올려가면서 카운트하는 방식이다.

먼저 일의자리를 카운트 하는데
0~9까지의 10칸짜리 배열을 만들고

정렬해야 할 배열을 순회하면서 카운트 소트와 동일한 방식으로 인덱스에 접근하여 값을 올린다.

그렇게 동일하게 일의자리에 관련해서 카운트 정렬을 진행한다.

그 뒤에 그렇게 정렬한 배열을 그대로 가지고 온다.

그렇게 완성된 일의 자리에 대한 정렬된 배열은
이제 input배열이 된다. (정렬해야 할 배열)

그 뒤 새로운 input 배열에 대하여 십의자리에 대해 count sort를 한다.

이런식으로 자리수를 가장 큰 값의 자리수까지 올려가면서 count sort를 반복하는 것을 Radix Sort라고 한다.

일의 자리로 정렬한 것을 input로 사용하면서
stability(안정성)한 성질이 유지되어지기 때문에 Radix Sort를 사용할 수 있다.

LSD : 작은 숫자 일의자리부터 비교

MSD : 큰 숫자 가장 큰 자리수부터 비교




