
다익스트라 알고리즘은

최단경로 탐색 알고리즘으로

인공위성 gps 소프트웨어 등에서 사용한다

이때 음의간선은 포함시킬 수 없다.

현실세계에서는 음의 간선이 없다.

여기서 음의간선이란?

가중치가 음수인 간선을 뜻한다.

다익스트라 알고리즘은 다이나믹 프로그래밍이다.

왜냐? 다익스트라에서 최단 거리는 여러개의 최단 거리로 이루어져 있기 때문이다.

다이나믹 프로그래밍은?
작은 문제가 큰 문제속에 비슷하게 포함되어있는 것을 말한다.

그래서 다익스트라 알고리즘은 다이나믹 프로그래밍이다.

다익스트라 알고리즘은 최단거리를 구할 때 그 이전까지의 최단거리를 모두 구한다는 특징이 있다.

다익스트라 알고리즘은 정렬을 사용해서 정렬 이후에 가장 작은 값을 포함시키는 방식으로 동작하기 때문에 greedy 알고리즘이라고 할 수 있다.

현재 보고있는 노드에 당장 붙어있는 노드들과의 거리를 확인한다.

그 다음에는 현재 갈 수 있는 노드들 중에서 가장 짧은 노드에서 다시 확인한다.

이번에 확인할 때는 만약 이전에 확인한 노드와 같은 노드가 새로 기준으로 하는 노드와 인접해 있다면 
처음 노드에서 이전에 확인한 노드와 같은 그 노드로 가는 최단거리를 구한다.
만약 해당노드로 가려고 할 따 간선을 2개 지나가야 하면 그 2개 간선의 합이 총 길이가 된다.


다익스트라라는 것은 현재까지의 최단거리를 갱신하는 알고리즘이다.


1. 출발점 정의

2. 출발점을 기준으로 각 노드의 최소비용을 저장한다.

3. 방문하지 않은 노드 중에서 가장 가까운 간선의 노드를 거쳐서 특정한 노드로 가는 경우를 고려해서 최소 비용을 갱신한다.

4. 3번 과정을 반복한다.


   1  --(2)-- 2
  ㅣ  \
  (1)  (5)
  ㅣ      \
   4--(3)--3

()안에 있는 숫자는 해당 간선의 비용을 말한다.

이런식으로 두었을 때 처음에 1번 노드에서 시작한다고 하면

1에서 갈 수 있는 노드들 즉 2 3 4까지의 최소비용을 저장한다. 각각 2 5 3이다.

이렇게 하면 1번에서 다른 노드들 까지의 최소비용을 담은 배열을 갱신하게 된다.


현재 갱신된 상태는

1   2   3   4
0   2   5   1

이 상태이다.

원래는 1을 제외하고는 모두 무한의 값이 들어갔다. 
1    2    3    4
0  무한  무한  무한
이유는 얼마나 걸릴지 모르기 때문에
어떤 길이 나와도 해당 길이 최소라고 인식하고 넣기 위해서 무한이라는 값을 사용했다.

그 후에 갱신된 테이블 중에서 가장 비용이 적은 노드인 4번을 선택한다.

   1  --(2)-- 2
  ㅣ  \
  (1)  (5)
  ㅣ      \
   4--(3)--3

4번 노드는 1, 2, 3이 연결되어 있다.

그러나 1은 이미 검사를 마친 내륙노드라고 인식한다.

그래서 1을 제외하고  2, 3까지의 비용만 확인한다.

현재 1 에서 4로가는 비용은 1이다.

그러니까 어디를 가든지 1이라는 비용은 기본적으로 포함시켜서 확인해야 한다.

그러면 4번에서 3번을 가는 비용은? 1 + 3 이기 때문에 4이다.

그러나 원래 1에서 3으로 가는 비용은 5였기 때문에 

원래의 최소비용을 담은 배열을 갱신해주어야 한다.

1   2   3   4
0   2   5   1
현재 이 상황에서

1   2   3   4
0   2   4   1

이렇게 갱신된다.

이런식으로 특정한 노드를 거쳐서 가는것이 더 싼 경우 값을 갱신해준다.

이것이 다익스트라 알고리즘의 기본 원리이다.


   1  --(2)-- 2
  ㅣ  \
  (1)  (5)
  ㅣ      \
   4--(3)--3

이제 현재 알고있는 비용 중에서 그 다음으로 작은 노드인 2번 노드로 가서 확인한다.

2번 노드는 1하고만연결되어있어서 확인 할 것이 더 이상 없다.

그러면 그 다음으로 비용이 적은 노드를 확인한다.

여기서는 3이다.

하지만 3에서 확인하였을 때도 이미 1 2 4가 모두 내륙이기 때문에 더 이상 확인할 것이 없다..

이런식으로 이미 확인을 마친 노드들은 내륙노드로 판단하여 추후에 다른노드들에서 해당 노드로 가는 것은 더 이상
확인하지 않는다.

이런식으로 매번 현재 상황에서 가장 비용이 적은 노드를 선택하기 때문에

그리디 알고리즘으로 분류할 수 있다.

최종적인 최소비용테이블은




  1  --(2)-- 2
  ㅣ  \
  (1)  (5)
  ㅣ      \
   4--(3)--3

1   2   3   4
0   2   4   1 이렇게 된다.

코드로 구현할 때는

해당 노드에서 다른노드로 가는 비용을 담아두는 배열을 만들어 두어야 한다.












