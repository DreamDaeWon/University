==kruskal 크러스컬 알고리즘==

뭔가 개인적으로 이름부터 강렬하다...
목록 싹 가져와! 한 다음에
싼거부터 짓는것이 크루스칼 알고리즘이다.

즉 사이클을 만들지 않을 때에만 욕심내어 그 간선을 추가한다.



==prim 프림 알고리즘==

프림은 뭔가 이름부터 부드럽다 키키~

부드러운 이름처럼 하나의 섬에 모아두고 가까운 섬부터 보면서
가까운 다리를 짓는 방식이다.

즉 거점으로부터 지을 수 있는 다리 중에 가장 싼게 얼마냐? 이런 말이다.




둘 다 가장싼거를 찾는 욕심쟁이이다. 그렇다 둘 다 그리디 알고리즘이다.


kruskalMST(G)

입력이 G다

가중치들을 오름차순으로 정렬할 것이다.




이거 둘 다 웃긴것이 다리로 생각하면 편하다 굳이 갈 수 있는 길이 있는데 왜 지어..? 짓지마~ 하는거다.
이 방식을 하면 자연스럽게 사이클을 방지할 수 있다.

하지만 그것을 검사할 때 우리가 모든 길을 다 고려하면 뇌가 터질수도있다.

이 때 생각한 방법이 선이 연결되어 있으면, 여러가지 선이 연결되어 있어도 1 - 5 - 6 - 8 - 4 이런식으로 되어있으면

하나의 트리로 본다. 다 연결되어있고 사이클이 없으니 트리? 인졍~

이 때 가장 작은 수가 루트노드가 된다.

즉 1번이 대장! 루트노드이다.

5 6 8 4 는 작지않아서 루트노드가 아니고 이 정점들도 루트 노드가 1이다.

그럼 다른 애들이 어떻게 이걸확인하냐?


바로바로 테이블을 만드는 것이다. 이게 유니온찾기이다.

테이블? 그냥 배열이다. 키키~


지금 1 5 6 8 4 이기 때문에 배열의 크기는 5개이고 각 배열 자리에 저장되는 것은 각 노드가 들어있는 트리의 루트노드이다.


루트노드를 뭘로 해도 괜찮지만 가장 작은 수를 루트 노드로 두는 것이 디버깅하기가 젤 쉽다 무야호~!





크루스칼 시간복잡도는 O(nglogmdlek)









PrimMST

prim의 mst 알고리즘



오늘은 프림 알고리즘이 하나의 점으로부터 시작해서 
추가 갱신 무시 셋중에 하나의 방식으로 n개의 점이 모두 포함될 때까지 한다 이게 중요!!!

이거랑 비슷한 방식으로 다익스트라(최단경로 알고리즘) 이걸 만들것이기 때문! 굉장히 엄청나~!





=========================================================


prim algorithm


전부 무한대가 들어있고

시작 인덱스까지 가는 법은 0

그래서 처음 돌 때는 나중에 0은 고려하면 안되기 때문에 처음에 0인 것을 찾아서 무한대로 값을 바꾸고 반환한다.

즉 처음 노드로 갈 때 위에 말한대로 무한으로 만들고 들어간다.



업데이트를 할 때는 주위의 점들을 보면서

1. 이미 내륙이다? 무시

2. 이 점까지 가는 정보가 없으면 추가한다. -> 추가

3. 정보가 있고 지금 알게 된 정보보다 이미 더 가까운게 있다? -> 무시

4. 이미 알고있는 가까운것 보다 더 가까운게 있어??? -> 갱신




만약 이것을 딕셔너리 방식으로 하면

해당 키가 존재하는지 판단해서 없으면 모르는 값이고





결국 프림은

해당 점의 정보가 없으면 정보를 추가하는 방식으로 나아간다.







== 힙 큐 ==
큐를 사용하는데
어떤 자료를 집어넣거나 삭제할 때마다

heapify를 사용하여 힙 상태를 만든다

즉 빼고 넣을 때 마다 logn시간복잡도가 든다.

그래도 정렬보다는 빠름 ^오^



파이썬에서 제공하는 알고리즘이다.

heapq

.heappop(힙 큐 이름)

이렇게 하면 맨 앞에것을 없애고 다시 힙 구조를 만든다.


.heappush(힙 큐 이름, 넣고싶은 숫자)

이렇게 하면 

원하는 숫자를 넣고 다시 제일 큰 숫자가 가장 위에 있는 힙 구조가 되도록 해준다.

그래서 heapq는 이름이 큐지만

사실 내부구현은 배열로 되어있다.

=================================

짜자잔~ 이제부터는 힙 큐를 이용해서 prim알고리즘을 수행할 것이다.

ㅋㅋ 사실 안쓴다고 한다...





교수님이 여러가지 다써보셨지만 가장 괜찮은 것이

hipdict 라는 자료형을 사용하신다고 한다.

hipdict는 파이썬의 내장모듈이 아니기 때문에 설치를 해야 한다.

hipdict는 키와 벨류의 값을 묶어서 튜플로 저장한다.

이것도 큐 처럼 hipdict.itempop()가 있다.

이것은 가장 작은 item을 뺀다.




내륙인 점을 제외한 뒤에 진행되는 과정은

가중치들을 저장해둔 곳에서


{시작위치가 키, (비용, 어디서부터?)}

이런 구조로 딕셔너리가 되어있다.


결국 최종적으로는

값이 존재하고 더 작아야만 바꾸고

나머지는 무시하면 된다.

물론 이 과정은 해당 점에서 다른 점으로 가는 간선들을 모두 조사하고
사이클이 발생할 수 있는 간선은 제외시키는 것을 한 뒤에 한다.


막간영어~
weight -> 가중치(무게)(비용)



결국 내륙에서 가장 가까운 것을 골라 연결하는 것이다.


그러면 즉 추가 무시 하는 그 딕셔너리에는 내륙은 포함되어지지 않는다.


크루스칼 알고리즘으로 찾은 kruskal 사이클을


우리는 최소값을 찾는데 힙 딕트가 존재하기 때문에 O(n)이 아니라 그냥 logn 이다.

이런식으로 노드의 개수가 n개이고 이것을 반복하기 때문에 nlogn이다.

즉 우리는 힙을 이용한 힙 딕트가 존재하기 때문에 nlogn이 된다.

하나 빼고 다른 간선하고 비교하고 이게 m번 실행될 수 있는데 하나의 점마다 다른 모든 점과 연결된 것이 아니라,
주변 몇 개의 점하고만 연결되어있기 때문에 상수개로 볼 수 있고 이는 최종 시간복잡도를 고려할 때는 무시된다.

그래서 O(n m logn) 이지만 m이 무시되어서 nlogn이 된다.


현재 내륙으로 부터 바로 연결할 수 있는 것들을 


하나의 점에서 주변의 몇 개만 연결된다. 즉 m과 n이

하나의 점에서 연결되는 간선의 수는 상수개이기 때문에 m의 개수가 무시된다.

(!!중요!!)
prim 알고리즘 알고리즘은 T안에 있는 점에서 항상 T 밖에 있는 점으로 연결되어지기 때문에 사이클이 반복되어지지 않는다.

즉 내륙을 제외하기 때문에 사이클이 발생할 수가 없음




== 다익스트라 알고리즘 ==

최단경로를 찾는 것이다.

주어진 출발점으로부터 
모든 도착점 까지의 가장 짧은 길 
및 거리를 구해내는 것이 다익스트라 알고리즘이다.


근데?
프림 알고리즘에서는 지금 눈 앞에 있는 것들만 확인하지만

다익스트라에서는 지금까지 지나온 경로를 모두 합한 것으로 비교한다.














