Tree/Graph 기초

tree
루트가 있고 아래로 차일드 노드들이 있고 노드를 연결하는 선 -> 엣지가 있다.

엣지의 방향은 위에서 아래로
들어오는 곳은 하나 나가는 곳은 여러곳
만약 트리가 엣지의 방향을 위아래로 조정할 수도있고 옆의 노드와 서로 주고받고
또는 엣지가 돌아서 다시 자기자신을 가리키기도 하고 등등
노드들끼리 다양한 상호작용을 할 수 있는 것 그것이 그래프이다.

그럼 트리는 뭐다? 방향이 있는 그래프이다.

여기서 그래프는 뭘까
Graph
그래프는 Vertex(Node)와 Edgi 엣지로 이루어져 있다.
엣지는 노드들 이어준다.
응용할 때는 노드들을 도시 엣지를 길 이런식으로 바꾸어 원하는 것을 구현한다.


Directed Graph -> 방향이 있는 그래프이다 이런경우에는 방향을 화살표로 나타내 주어야 한다

? 그러나 트리는 방향을 화살표로 나타내주지 않는다. 왜그럴까?
그 이유는 트리는 항상 아래 방향으로 가기 때문에 굳이 해주지 않는것이다. 

Undirected Graph - > 방향이 없는 그래프이다. 이런 경우에는 방향을 화살표로 나타내지 않고 그냥 노드끼리 직선으로 연결한다.

Cyclic Graph-> 하나 이상의 사이클이 존재하는 그래프를 말한다.
여기서 사이클이란 노드들이 뺑뺑이 도는 구조가 있는 것을 말한다.

Acyclic Graph -> 사이클이 없는 그래프를 뜻한다.


그래프를 표현하는 방법에는 두 가지가 있다.

Adjacency Matrix-> 그래프를 이차원 배열로 표현하는 것을 말한다.

  1
/ ㅣ \
2 ㅣ  3         이런식으로 연결되어 있을 때
  ㅣ /          2차원 배열로 표시하면
  4              
                1  2  3  4
              1 0  1  1  1
              2 1  0  0  0
              3 1  0  0  1
              4 1  0  1  0

              이런식으로 인접한(Adjacency)이라는 뜻이 있기 때문에 간접적인 것은 무시한다 ex(2-3)
              이런식으로 직접 연결되어있는 인접한 노드가 있으면 1로 아니면 0 으로 표현하는 것을 말한다.

              만약 방향이 있다면
              1 -> 2 일 때

              1  2
            1 0  1
            2 0  0

            이런식으로 열 기준으로 화살표를 보내면 1 아니면 0으로 표현한다.

          

Adjacency List-> 해당 노드와 인접한 노드들을 그냥 쭉 나열하는 것이다.

위의 그래프와 동일하다고 가정하면
1 - 2 - 3 - 4
2 - 1
3 - 1 - 4
4 - 1 - 3

이런식으로 순서상관없이 그냥 쭉 나열하는 방법을 말한다.

여기에서 이 리스트안에 있는 노드들의 개수는 엣지의 개수를 n 이라고 하면 2n개만큼 존재한다.
당연한 말이다. 예를 들어 1 과 2가 연결되어있다면, 
리스트에서 1의 리스트에서는 2가
2의 리스트에서는 1이 이렇게 각각 2번 적기 때문이다.


Union-Find

합집합 찾기라고도 불리는 알고리즘으로 그래프의 대표적인 알고리즘 중 하나이다.

서로소 집합 알고리즘이라고도 부른다.(Disjoint-Set)

서로 같은 집합이 아닌 것을 찾는 것과 같은 알고리즘이다.

여러개의 노드가 존재할 때 두 개의 노드르 선택해서, 현재 이 두 노드가 서로 같은 그래프에 속하는지 판별하는 알고리즘이다.


여러개의 노드가 자유분방하게 있을 때
즉, 여러개의 노드가 각자 자기 자신만의 집합을 원소로 가지고 있을 때 모든 값이 자기 자신을 가리키도록만든다.

배열로 표현하면 보통 첫 번째 행에는 노드번호를 의미하고
두 번재 행에는 부모 노드 번호를 입력한다. 자신이 어떠한 부모에 포함되어 있느지를 의미함.

이때는 각자자신만의 집합을 각각의 노드들이 따로 가지고 있기 때문에, 부모노드도 자기 자신이 된다.

1 2
    3
      4


1  2  3  4
1  2  3  4


만약 어떤 노드들이 합쳐지면 그 합쳐지는 과정을 유니온(Union : 합침 이라는 뜻)이라고 한다.


1 - 2
     3
       4

이런식으로 1과 2를 연결되어지

노드 : 1  2  3  4
부모 : 1  1  3  4

이렇게 부모를 합치는데 부모를 합칠때는 더 작은 값으로 부모를 합치게 된다.


1 - 2
     \
      3
      
        4

그럼 만약 이런식으로 1-2-3 이렇게 연결되어지면 어떨까?


노드 : 1  2  3  4
부모 : 1  1  2  4

이런 형태로 될까?

아니다!!!!!

유니온 함수가 재귀적으로 실행되면서 3의부모인 2로가서 2의 부모도 찾아내기 때문에
결과적으로는 3도 2의 부모인 1로 합쳐지게 된다.

노드 : 1  2  3  4
부모 : 1  1  1  4

유니온은 재귀적으로 진행하기 때문에 상당히 직관적으로 코드를 짧게 작성할 수 있다.

이게 Union-Find 의 전부이다.


이런식으로 배열을 만들어 둔 후에
두 개의 노드를 골랐을 때 그 두가지 노드의 부모를 확인하여 같은 그룹에 속하였는지 아닌지를 찾아준다.

코드로 구현할 때는 getParent, unionParent, findParent 함수들을 이용하여 구현한다.

getParent : 해당노드의 부모 노드가 무엇인지 찾아준다.
unionParent : 두 부모 노드를 합치는 함수이다.
findParent : 두개의 노드를 입력받았을 때 두 개의 노드가 같은 부모를 갖는 지 알려주는 함수이다.

이 세가지 핵심 함수를 이용하여 코드를 구현한다.



MST


  Kruskal
크루스칼 알고리즘은 가장 적은 비용으로 모든 노드를 연걸하기 위해 사용하는 알고리즘이다.
최소 비용 신장 트리를 만드기 위한 알고리즘 이라고 한다.

예시로는 모든 도시를 연결하려고 할 때 가장 적은 비용으로 할 수 있기에 실제로 적용되는 알고리즘이다.

용어로는
노드 = 정점 = 도시 : 동그라미
간선 = 거리 = 비용 : 선


1 - 2
\ / |
 3  |
  \ |
    5
    /
   4

이런식으로 연결되어있다면 노드는 5개 간선은 6개이다.

이런식으로 모든 노드들이 연결되어 있을 때

가장 적은비용으로 모든 노드를 잇는 방법은 무엇일까? 에 대해서 찾는것이 크루스칼 알고리즘이다.
-

이렇게 최소 비용 신장 트리를 만들때는 사용되는 간선의 개수가 반드시 노드개수 -1 이다.
즉 
간선 = n(노드개수)-1 이다.

위의 그림에서는 노드가 5개이기 때문에 간선은 4개여야 한다.


이것을 구현하는 방법은 이 문장만 기억하면 된다.

"간선을 거리가 짧은 순서대로 그래프에 포함시킨다."

모든 노드들을 연결만 시키면 되기 때문에
모든 노드의 간선정보를 배열에 저장하여 거리를 기준으로 오름차순으로 정렬하면 된다.

그리고 최소비용신장트리를 만들 때는 사이클이 있을 이유가 없기때문에
사이클이 있으면 안된다.

알고리즘은

1. 정렬된 순서에 맞게 그래프에 포함시킨다.
2. 포함시키기 전에는 사이클 테이블을 확인한다.
3. 사이클을 형성하는 경우 간선을 포함하지 않는다.

이런 과정을 거친다.

여기서 위에서 배운 유니온 find를 사용하여 부모 노드가 있는 사이클 테이블을 만들어
사이클인지 판별할 수 있다.

판별하는 법은 이으려고 하는 두 노드가 같은 부모를 가지면 이었을 경우 사이클이 발생하기 때문에
연결하지 않고 건너뛰면 된다.









