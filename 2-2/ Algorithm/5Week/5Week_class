분할정복을 쓰기 좋은 경우는
반으로 잘랐을 때 딱 반으로 갈라지는 경우를 말한다.

퀵정렬 분할정렬 차이
퀵정렬은 꼭 반반으로 쪼개진다는 보장이 없다.

분할정렬은 우리 수업에서는 반반으로 쪼개지는 경우를 다룰것이다.


즉 분할정복 알고리즘 같은 경우에는 문제를 분할시켜서 작은 문제로 만든 뒤 정렬하고
추후에 다시 합치는 경우를 말한다.


분할정복에는 두 가지 알고리즘이 있다.
합병정렬과 퀵 정렬이다.


1. 합병정렬============================
- 실전에서 쓰인다.
- 분할을 한 뒤에 합병을 한다.

- 데이터의 개수가 적어질수록 불리하다
(그래서 일정 개수 이하가 되면 삽입정렬로 정렬한다.)

- 합병정렬은 stable하다.
- 합병정렬은 외부 정렬의 기본이 되는 장렬 알고리즘이다.
- 시간복잡도가 빠르다.


합병과정
- 각각 나뉘어 분류 된 두 개의 배열을
앞의 인덱스부터 비교하여
더 작은 수를 최종배열의 앞쪽부터 차근차근 채워나간다.

0번 배열과 1번배열의 원소를 비교했을 때 값이 같다면

0번 배열것을 최종 배열에 넣는다
앞의 배열의 것을 넣는 이유는 stable한 특성을 지키기 위해서다.



그래서 총 하는 법은

1. 왼쪽 절반을 머지소트 한다
2. 오른쪽 절반을 머지소트 한다
3. 합병(머지)한다.


시간복잡도 O(nlogn)


단점 - 입력을 위한 메모리 공간 외에 추가로 입력과 같은 크기의 공간이
필요하다.

====================================


2. 퀵 정렬==============================

- 퀵 정렬은 분할정복 알고리즘으로 분류된다.
정복 후 분할한다.

- 퀵정렬 알고리즘은 시간복잡도가 O(nlogn)

- 피봇을 선정하고 피봇을 기준으로 나눈다.

- 퀵소트는 배열안에서 모두 처리하기 때문에 추가 배열이 필요하지는 않다.
그러나, 공간복잡도는  상수가 아닌 log(n)이다.
그 이유는 재귀호출을 하면서 계속 스택메모리를 사용하기 때문이다.

- 퀵 소트는 재귀호출 하기 때문에 한 번 호출할때마다
오버헤드가 있다.
그래서 병합정렬과 같이 퀵 소트도 일정 개수보다 낮게 된다면
삽입정렬로 처리한다.


퀵 정렬을 하는 방법

- 파티션(나누는 것)이라는 과정을 거친다.

1. 피봇값을 하나 고른다.

2. 피봇보다 작은값은 왼쪽으로 큰 값은 오른쪽으로 보낸다.
	2-1) 이 과정에서 앞쪽에서 피봇보다 뒤로 가야하는 숫자를 찾은 후
	2-2) 뒤쪽부터 앞쪽으로 한칵씩 이동해서 앞쪽으로 가야하는 숫자를 찾는다.
	2-3) 그 후 두 숫자를 스왑한다.

3. 만약 피봇과 값이 같다면 그냥 왼쪽으로 보낸다 (stable하지 않음)

4. 모두 나누었다면 피봇은 최종위치가 결정된 것이다.

5. 이 과정을 반복한다.


요약하면
- 파티션(나누기)
- 퀵소트(왼쪽)
- 퀵소트(오른쪽)


피봇으로 항상 작은숫자가 선택되는 경우
-랜덤이라면 많이 그러지는 않겠지만
만약 앞에서부터 고르는데 이미 정렬된 배열이 들어오는 경우
시간복잡도가 O(n^2) 만큼 증가한다.

최적은 정확히 반으로 가르면 가장 좋아진다.
O(nlogn)이다.

사실 최악만 아니면 O(nlogn)이다.

그럼 피봇을 어떻게 골라야 할까?
- 랜덤
	랜덤하게만 골라도 시간복잡도가 O(n^2) 이 되는것을 피할 수 있다.

- 3등분 하기
	


개수가 많을 때는 피봇을 잘 선택하는데 시간을 좀 더 들여서
최대한 반반으로 나눌 수 있는 방법을 찾아서 택하면
가장 빠르게 돌릴 수 있다.

단, 배열의 원소의 개수가 적으면 그냥 가장 빠르게 피봇을 고르는 것이 더 낫다.


퀵 정렬은 입력의 크기가 클 때 가장좋은 성능을 보이는 알고리즘이다.

=====================================


선택 문제=================================

원하는 번째만큼 큰 숫자를 찾기 위한 알고리즘

선택 문제는 n개의 숫자들 중에서 k 번째로 작은 숫자를 찾는 문제
ex) 10개의 숫자에서 5번째로 작은 숫자를 찾는 것

Select 방식
피봇을 하나 정하고
그 다음에 오른쪽으로 한칸씩 비교하면서 피봇값보다 큰것은 
바뀌지 않은 원소들 중에서
가장 오른쪽에 있는 원소를 검사하여 
그 원소가 피봇보다 작다면 그 원소와 앞에서 검사한
작은 원소의 위치를 바꾼다.
만약 바뀌지 않은 원소들 중 마지막 원소가 피봇값보다 크다면
한 칸 앞에있는 것과 비교하고 위에 적은 과정을 수행한다.

바뀌지 않은 마지막 원소가 나왔다면 그 원소와 피봇값을 비교하여
피봇의 숫자가 더 크다면 피봇의 위치를 그 원소와 바꿔준다.

그렇게 피봇의 위치가 확정되어지고, 원하는 숫자가 몇 번째로 크냐에 따라

small group에서 새로운 피봇값을 구하여 위의 과정을 반복할 지
아니면 large group에서 새로운 피봇값을 정하고 위의 과정을 반복할 지 고른다.

딱 맞다면 탈출한다.

이 과정에서는 피봇을 랜덤하게 정하기 때문에
랜덤 알고리즘 이라고 부르기도 한다.

피봇이 너무 한쪽으로 치우치게 분할하면 알고리즘의 수행시간이 길어진다.


시간복잡도는 O(n)이다.

========================================


good/bad 분할 정의

좋은 분할은 두 그룹으로 나누었을 때 양쪽 그룹의 크기가 다 3/4 보다 작은 경우를 말한다.

나쁜 분할은 한쪽이 3/4보다 크면 나쁜 분할이라고 표현한다.


이 때 좋은분할과 나쁜 분할이 나올확률은 반반이다.


좋은 분할이 두 번 연속으로 하게 되면 좋은 분할을 할 수 있다고 한다.

사이사이에 나쁜 분할이 끼어 있어도 좋은분할만 했을 때*2 정도의 성능을 낼 수 있다고 한다.



============================================


선택알고리즘과 이진탐색


유사성

이진탐색 - 정확히 반

선택알고리즘 - 정확히 반은 아님


공통점

부분 문제들을 취합하는 과정이 필요 없다.

=============================================


분할정렬 알고리즘 : 문제를 분할해서 문제를 해결하는(정복하는) 방식이다.

합병정렬

합병정렬의 공간복잡도는 O(n)이다. 즉 입력한 배열의 크기만큼의 크기가 더 든다.


퀵 정렬 알고리즘은 시간복잡도가 O(nlogn)이다 최악의 시간복잡도는 O(n^2)이지만.

어떻게든 O(nlogn)으로 만든다.


==============================================


최근접 점 쌍찾기 (closest Pair)

2차원 평면상에 다양한 점이 주어졌을 때 가장 가까운 두 점 (한 쌍)을 찾는 알고리즘이다.


간단한 방법 (brute force)

brute force가 뭘까?

무차별 대입 공격이다. ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ

두 점 사이의 거리를 계산하여 가장 가까운 점의 쌍을 찾기
시간복잡도 O(n^2)

3개일때는 간단한 방법이 유일하다.



더 좋은 방법은?


분할정복 방법이 있다.

근데 취합 할 때 어떤 두 점 사이를 가르게 되면 그 두 점의 거리를 계산할 수 없기 때문에
그 부분까지 고려해 주어야 한다.


필요한 것
-데이터 (x,y)좌표


conquer

4개 이상일 때는 반으로 나누어서 두 그룹에서 가장 가까운 것을 구하고 
두 그룹에서 가장 가까운 것들끼리 비교한다.

그냥 나누어서 비교하면 중간에 나누어진 
즉, 중간영역에 있는 점들의 거리를 구하지 않기 때문에 문제가 발생한다.

그래서 중간 영역에 있는 애들도 계산해 주어야 한다.



그럼 어떻게 할까?

두 그룹에서 가장 짧은 거리만큼이 10이라면
중간에 나눈 부분에서 왼쪽 그룹의 가장 오른쪽에 있는 점을 기준으로 좌 우 범위를 찾는다.
왼쪽 10 오른쪽 10 범위에 있는 점들까지만 비교하는 것을 말한다.


그럼 중간영역의 점들을 어떻게 알까?

점들이 들어있는 배열을 x좌표의 오름차순으로 정렬한다.
그러면 거기서 반을 자르기 때문에 나눈 부분에서 가까운 점들을 알 수 있게 된다.



합칠 때 y축을 기준으로도 정렬하면 왼쪽 그룹의 가장 오른쪽에 있는 점과 다른애들을 비교할 때
y축으로 가장 가까운 점 하나만 비교하고 그 외에는 어차피 그것보다 멀기 때문에 비교하지 않아도 된다.


그러면 사이에 있는 정점들을 매번 합칠때마다 y축 정렬을 하냐?
그러면 너무 오래걸린다.
점 4개마다 나누기 때문에

그래서 처음부터 정점이 들어있는 총 배열을 y축 정렬해두고

나중에 합칠 때 범위 안에있는 정점들이 인덱스 몇~몇까지 인지 구한다.

그 다음에 y값으로 정렬되어 있는 것 중에서 인덱스가 그 사이에 있는 것들을 찾는다.

즉 2, 4, 6 이 점이 필요하다고 판별이 나면

y축 정렬된 배열에 ex) 8, 3, 6, 5, 1, 4 이런식으로 있다고 하면

y축 정렬된 배열을 돌면서 if (2 or 4 or 6) 이게 만족한다면
새로운 배열 공간을 만들어 넣는 차례로 정리해두면 된다.

이렇게 하면 매번 합칠 때마다 n^2의 시간복잡도가 들지 않게 된다.


결국 이 방법들도 분할정복 방법으로 문제를 해결하는 것이다.



만약 처음에 전체 배열에 대한 y축 정렬을 하지 않았다면?
최근접 점 쌍찾기 알고리즘은 시간복잡도가 O(nlog^2 n)이다

근데? 우리가 전체 배열을 먼저 y축 정렬을 해두었기 때문에 시간복잡도가
O(nlogn)이 된다.


