1. 버블정렬, 선택정렬, 삽입정렬이 나온다.
모두 동작방식이 다르지만 시간복잡도가
O(N^2)으로 같다.

하지만 실제로는 삽입정렬>선택정렬>버블정렬 순으로 빠르다.

그 이유는
버블정렬은 모든 비교를 한 후에 스왑을 하게되는데 선택정렬은 매 사이클마다 
한 번의 스왑만 진행하면 되기 때문에 버블정렬보다 2배 빠를 수 있다.

더 나아가 삽입정렬은 필요한 아이템만 스캔을 하기 때문에 선택정렬보다 더 빠르다.

이렇게 시간복잡도가 같은데 실제 속도가 조금씩 다른 경우 최악의 시나리오보다 평균적인 시나리오를 보는것이 더 낫다. 최고, 최악의 시나리오는 잘 안나오기 때문이다.



버블정렬

앞에서부터 2개씩 인접한 자료와 비교하여 순서가 맞으면 건너뛰고 안맞으면 자리를 바꾼다.
이렇게 비교하는 것을 전체 배열만큼 돌기 때문에 시간복잡도는 O(n^2)이 된다.

코드로 구현하면 재귀함수로 만든다.


선택정렬

선택정렬은 배열을 순회하면서 가장 작은 값 부터 앞으로 하나씩 옮기는 것이다.
모든 인덱스를 순회하면서 가장 작은 값을 찾는다.

가장 작은값을 찾았으면 맨 앞의 자료와 스왑해준다.
이것을 자료의 개수만큼 반복한다.

시간복잡도는 O(n^2) 이다.

재귀함수로 구현한다.



셸정렬
삽입정렬의 단점을 보완하기 위한 알고리즘이다.
셸 정렬은 각 자료마다의 갭을 둬서 각 단계로 나눈 뒤에 삽입정렬을 하는 것이다.

삽입정렬도 최악의 경우 시간복잡도가 O(n^2)이다.
그러나 실제 런타임 시간을 살펴보면 삽입정렬이 7.43초인것에 비해 셸 정렬은 0.05초로
삽입정렬보다 훨씬 빠르다.

코드로 구현할때는 매개변수로 갭을 받아와서 그 갭만큼 띄엄띄엄 삽입정렬을 해주는식으로 구현한다. 
한번 삽입정렬을 돌면  gap/2를 해주어 갭이 점점 줄도록 만들어준다.

셸정렬을 요약하면 삽입정렬을 나눠서 하는 것이다.


트리


트리란 배열 링크드 리스트같이 그냥 라인으로 이루어진 일직선 구조가 아니라 부모 자식관계가 있는
계층적 구조이다.

이진트리
자식노드가 최대 2개까지 붙는 트리를 이진트리라고 부른다

ternary tree
자식노드가 3개까지 붙는것을 말한다.

일반 이진트리에 반해 이진검색트리는 규칙이 하나 더 붙는다. 
어떤 노드가 있을 때 그 노드의 왼쪽에 있는 자식트리는 해당노드보다 작아야하고 
오른쪽에 있는 자식트리는 해당 노드보다 커야한다.
이렇게 정리하면 어떤 값을 찾을 때 해당 노드보다 크면 오른쪽 작으면 왼쪽으로 타고내려가면 된다.

밸런스
너무 지나치게 한쪽으로 치우쳐져 있지 않으면 밸런스가 맞다고 한다.
대표적으로는 레드블랙트리, AVL트리가 있다.

완전 이진 트리

완전 이진트리는 노드들이 무조건 왼쪽부터 채워져 있으면 완전 이진트리이다. 
마지막 레벨을 제외하고는 모든 노드들이 채워져 있어야 한다.


Full binary tree

노드들의 자식이 하나도 없거나 2개로 다 채워져있는 트리를 말한다.

Perfect Binary Tree

레벨을 n이라고 할 때 해당 트리의 총 노드의 개수가 2^n - 1개일때를 말한다.
즉 모든 마지막레벨까지 꽉 차있는 상태를 말한다.

Binary Heap

최소 힙과 최대 힙이있다.
최소 힙 : 작은값을 항상 위에 있게해서 해당 트리의 루트노드가 가장 작은값이 오도록 한다.

최대 힙 : 최소 힙과 개념이 반대이다. 
큰 값이 항상 위에 있도록 하여 해당 트리의 루트노드가 최대값이 있도록 하는것을 말한다.

최소 힙으로 정렬하는 것은 본인과 부모노드를 비교하여 계속 부모노드보다 작으면 계속 바꾸면서
올라가도록 만든다. 
시간복잡도는 O(logn)이다.

트리에서 루트를 뺀 후에 다시 정렬할 때도 O(logn)이다.

Heap Sort

힙정렬은 병합 정렬과 퀵 정렬만큼 빠른 정렬 알고리즘이다.
힙 트리 구조를 이용하는 정렬방법이다.

힙을 이용하면 더 빠른 정렬을 할 수 있지 않을까? 라는 아이디어로부터 시작했다고 한다.

어떤 한 노드에 의해 힙이 붕괴되어지지 않도록 힙 생성 알고리즘을 사용한다.

힙 생성 알고리즘은 어떤 한 노드에 의해 힙이 붕괴되었을 경우
붕괴의 원인인 노드보다 아래에 있는 노드들과 비교하여 그 노드가 붕괴의 원인이 된 노드보다
클 경우에 바꿔주는 알고리즘을 말한다. (최대 힙(Max Heap)의 경우)

힙 생성 알고리즘은 시간복잡도가 O(n)이다.

배열로 힙 정렬을 구현하면

먼저 배열을 9칸으로 생성한다.
그리고 현재 배열을 돌 때 보고있는 노드의 인덱스를 k라고 할 때
부모의 인덱스는 int (k-1)/2를 하면 된다. 이렇게 하면
2일 때도 (2 - 1)/2 = 0.5 이지만 int 형이기때문에 소수점이 짤려 0이 된다.

그 뒤에 if문을 통해 본인의 값이 부모의 값보다 크면 바꿔주는
쉽게말해 스왑을 해주는 코드를 작성하면 된다.

비교, 스왑까지완료했다면 k를 본인의 부모노드의 인덱스가 되도록 바꿔준 뒤
해당 트리의 루트노드인 0 이 될 때까지 반복한다.

가장 큰 값을 가장 마지막 노드와 바꿔준 후 그 값을 제외하고 다시 힙을 구성하고
그 다음번에는 가장 마지막 노드-1 번째와 바꿔준 후 다시 힙을 구성하는 식으로
반복하면 된다.

이렇게 하면 시간복잡도는 (힙을 구성하는 시간 * 노드의 총 개수) 이므로
O(n*logn)이 된다.





