cppreference 사이트가 교과서이다.

cpp core guidelines 이것도 봐야한다.

유튜브에 cpp con 이라는 채널을 보면 된다.


// 객체와 메모리 영역 - 많은 수의 객체를 어느 메모리에 저장할까?
// OS가 구분한다
// 1. STACK 
// 2. DATA, 
// 3. free-store(heap은 공식 C++문서에 없다 그래서 안씀)
// 
// 1,2와 3의 구분 - compile time에 메모리 크기를 아는 경우/크기 변동이 없을 때
// 1과 2의 구분 - 1의 한계(비쥬얼스튜디오 기본 설정인 default 1M 바이트)를 초과하면 2를 사용한다.

우리가 프로그램을 실행시키면

메모리가

| 이쪽이 낮은 번지 
| stack
----------------------
| free store - RAII
---------------------
| 초기화X
| 초기화O  DATA
---------------------
| CODE - TEXT
|
| 이쪽이 높은 번지

RAII는 스택 언와인딩에서 함수구간을 나갈 때 해당 함수 구간에서 생성한 것들을 거슬러 올라가면서 소멸자를 호출하기 때문에
생성할 때 자원을 묶어주면 어떨까? 하는 아이디어에서 나옴

자원의 생명주기를 객체의 생명주기와 일치시키는 것


void f()
{

// 아래 변수는 p가 핸들러임 자원을 관리하기 위한 것 p가 new Dog를 핸들링하는 것
// new Dog라는 자원의 생명주기를 p라는 객체의 생명주기와 일치하도록 생성시의 자원을 얻어오도록 한다.

스마트 p{ new Dog }; // 이렇게 붙여서 초기화해주는 것 만을 스마트 포인터에서 초기화하는 것이라고 한다.

// 예외 발생 // 스택 언와인딩 (되감아가면서 스택 메모리를 다시 돌린다.)
	throw 20250325; // 비명 질렀다. 근데 안받아주면? 내부적으로 있는 어보트 뭐시기 함수로 죽음

	std::cout << "throw 때문에 이 문장은 출력 안됨";
}


